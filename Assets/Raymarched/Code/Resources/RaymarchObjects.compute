// Referenced: https://www.youtube.com/watch?v=BNZtUB7yhX4
#pragma kernel RenderRaymarch
#include "UnityCG.cginc"

struct RaymarchedObj
{
    int type;
    int solidType;
    int repeating;
    float3 position;
    float3 repeatSize;
    float3 color;
    float param0;
    float param1;
    float param2;
    float param3;
    float param4;
    float param5;
    float param6;
    float param7;
    float param8;
    float param9;
};

// Camera vars

float2 size;
float4x4 camToWorld, camInverseProjection;
float3 cameraPos;
float camFarPlane, camNearPlane;
Texture2DArray<float> _CameraDepthTexture; // HDRP Depth Texture Array
StructuredBuffer<int2> _DepthPyramidMipLevelOffsets;

// Camera functions

// Gets the view ray direction from a screen coordinate
inline float3 getCamRayDir(float2 coord)
{
    return normalize(mul(camToWorld, float4(mul(camInverseProjection, float4(coord, 0.0f, 1.0f)).xyz, 0.0f)).xyz);
}

float getCamDepth(int2 coord)
{
    int2 mipCoord = coord.xy >> int(0);
    int2 mipOffset = _DepthPyramidMipLevelOffsets[int(0)];
    return Linear01Depth(_CameraDepthTexture.Load(int4(mipOffset + mipCoord, 0, 0)));
}

// SDFs

float sdfSphere(float3 pt, float rad)
{
    return length(pt) - rad;
}

float sdfBox(float3 pt, float3 box)
{
    float3 q = abs(pt) - box;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdfMandlebulb(float3 pt, int steps)
{
    float3 w = pt;
    float m = dot(w, w);

    float4 trap = float4(abs(w), m);
    float dz = 1.0;
    
    for (int i = 0; i < steps; i++)
    {
#if 0
        // polynomial version (no trigonometrics, but MUCH slower)
        float m2 = m*m;
        float m4 = m2*m2;
		dz = 8.0*sqrt(m4*m2*m)*dz + 1.0;

        float x = w.x; float x2 = x*x; float x4 = x2*x2;
        float y = w.y; float y2 = y*y; float y4 = y2*y2;
        float z = w.z; float z2 = z*z; float z4 = z2*z2;

        float k3 = x2 + z2;
        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );
        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;
        float k4 = x2 - y2 + z2;

        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;
        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;
        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;
#else
        // trigonometric version (MUCH faster than polynomial)
        
        // dz = 8*z^7*dz
        dz = 8.0 * pow(m, 3.5) * dz + 1.0;
      
        // z = z^8+c
        float r = length(w);
        float b = 8.0 * acos(w.y / r);
        float a = 8.0 * atan2(w.x, w.z);
        w = pt + pow(r, 8.0) * float3(sin(b) * sin(a), cos(b), sin(b) * cos(a));
#endif        
        
        trap = min(trap, float4(abs(w), m));

        m = dot(w, w);
        if (m > 256.0)
            break;
    }

    // distance estimation (through the Hubbard-Douady potential)
    return 0.25 * log(m) * sqrt(m) / dz;
}

// Raymarching vars

int maxIterations;
int objectCount;
float3 sunDir;
float ambientLight;
float resolution;

// Buffers

StructuredBuffer<RaymarchedObj> objects;
RWTexture2D<float4> result;

// Raymarching fucntions

float mod(float x, float y)
{
    return x - y * floor(x / y);
}

// Get scene color and min value
float4 sampleSceneSDF(float3 pt)
{
    float sdfVal = 2000000000;
    float3 color = objects[0].color;
    float3 objPos;
    
    for (int i = 0; i < objectCount; i++)
    {
        if (objects[i].solidType == 0)
        {
            float newSDFVal = 2000000000;
            float3 objPos = pt;
        
            if (objects[i].repeating)
            {
                float3 objRepeat = objects[i].repeatSize / 2;
                objPos = float3(mod(objPos.x + objRepeat.x, objRepeat.x * 2) - objRepeat.x,
                            mod(objPos.y + objRepeat.y, objRepeat.y * 2) - objRepeat.y,
                            mod(objPos.z + objRepeat.z, objRepeat.z * 2) - objRepeat.z);
            }
        
            if (objects[i].type == 0)
                newSDFVal = sdfSphere(objPos - objects[i].position, objects[i].param0);
            else
                newSDFVal = sdfBox(objPos - objects[i].position, float3(objects[i].param0, objects[i].param1, objects[i].param2));
            
            if (newSDFVal < sdfVal)
            {
                sdfVal = min(newSDFVal, sdfVal);
                color = objects[i].color;
            }
        }
    }
    
    for (i = 0; i < objectCount; i++)
    {
        if (objects[i].solidType == 1)
        {
            float newSDFVal = 2000000000;
            float3 objPos = pt;
        
            if (objects[i].repeating)
            {
                float3 objRepeat = objects[i].repeatSize / 2;
                objPos = float3(mod(objPos.x + objRepeat.x, objRepeat.x * 2) - objRepeat.x,
                            mod(objPos.y + objRepeat.y, objRepeat.y * 2) - objRepeat.y,
                            mod(objPos.z + objRepeat.z, objRepeat.z * 2) - objRepeat.z);
            }
            
            if (objects[i].type == 0)
                newSDFVal = sdfSphere(objPos - objects[i].position, objects[i].param0);
            else
                newSDFVal = sdfBox(objPos - objects[i].position, float3(objects[i].param0, objects[i].param1, objects[i].param2));
            
            sdfVal = max(-newSDFVal, sdfVal);
        }
    }
    
    return float4(color, sdfVal);
}

// Calculates the normal from a sdf hit point
float3 calcNormal(float3 pt)
{
    const float EPS = 0.0001f;
    const float2 h = float2(EPS, 0);
    return normalize(float3(sampleSceneSDF(pt + h.xyy).w - sampleSceneSDF(pt - h.xyy).w,
                           sampleSceneSDF(pt + h.yxy).w - sampleSceneSDF(pt - h.yxy).w,
                           sampleSceneSDF(pt + h.yyx).w - sampleSceneSDF(pt - h.yyx).w));
}

// Calculates the lighting amount based on a normal vector
float normalLighting(float3 normal)
{
    return clamp(dot(sunDir, normal), 0, 1);
}

// Debug vars

int debugRayCount;

// Raymarches the scene
[numthreads(8, 8, 1)]
void RenderRaymarch(uint3 id : SV_DispatchThreadID)
{
    // Get ray
    
    float2 percentOnTex = id.xy / size;
    float3 curRayDir = getCamRayDir(percentOnTex * 2 - 1);
    
    // Perform raymarching
    
    float depth = getCamDepth(id.xy);
    float distOnRay = camNearPlane;
    
    int i = 0;
    for (i; i < maxIterations; i++)
    {
        float3 curRayPt = cameraPos + (distOnRay * curRayDir);
        float4 sceneVal = sampleSceneSDF(curRayPt);
        
        if (sceneVal.w < resolution)
        {
            float3 normal = calcNormal(curRayPt);
            float lightAmt = normalLighting(normal) + ambientLight;
            
            result[id.xy] = float4(sceneVal.rgb * lightAmt, 1);
            break;
        }
        
        if (distOnRay / camFarPlane > depth)
            break;
        distOnRay += sceneVal.w;
    }
    
    if (debugRayCount)
        result[id.xy] = float4(i / (float) maxIterations, 0, 0, 1);
}

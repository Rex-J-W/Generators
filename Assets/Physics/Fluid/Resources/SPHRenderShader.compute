#pragma kernel Render

// Particle data

struct Particle
{
    float density, pressure;
    float3 curForce, velocity, position;
};

// Render variables

int iterations;
float2 size;
float4x4 camToWorld, camInverseProjection;

// Gets the view ray direction from a screen coordinate
inline float3 getCamRayDir(float2 coord)
{
    return normalize(mul(camToWorld, float4(mul(camInverseProjection, float4(coord, 0.0f, 1.0f)).xyz, 0.0f)).xyz);
}

// Calculates ray-AABB intersection
// Adapted from : https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms
float2 rayIntersectAABB(float3 lb, float3 rt, float3 org, float3 dir)
{
    // dir is unit direction vector of ray
    float3 dirfrac = float3(1.0f / dir.x, 1.0f / dir.y, 1.0f / dir.z);
    
    // lb is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
    // org is origin of ray
    float t1 = (lb.x - org.x) * dirfrac.x;
    float t2 = (rt.x - org.x) * dirfrac.x;
    float t3 = (lb.y - org.y) * dirfrac.y;
    float t4 = (rt.y - org.y) * dirfrac.y;
    float t5 = (lb.z - org.z) * dirfrac.z;
    float t6 = (rt.z - org.z) * dirfrac.z;

    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
    
    // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us
    if (tmax < 0)
        return float2(-1, -1);

    // if tmin > tmax, ray doesn't intersect AABB
    if (tmin > tmax)
        return float2(-1, -1);
    
    return float2(tmin, tmax);
}

// Data variables

float3 leftBottomAABB;
float3 rightTopAABB;
uint particleCount;
float testRad;
StructuredBuffer<Particle> particleBuffer;
RWTexture2D<float4> result;

// Raymarches the fluid volume
[numthreads(8, 8, 1)]
void Render(uint3 id : SV_DispatchThreadID)
{
    float2 percentOnTex = id.xy / size;
    float3 curRayOrigin = mul(camToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz,
			curRayDir = getCamRayDir(percentOnTex * 2 - 1);
    
    float2 aabbTest = rayIntersectAABB(leftBottomAABB, rightTopAABB, curRayOrigin, curRayDir);
    if (aabbTest.x != -1)
    {
        //float distOnRay = clamp(atmoLength / iterations, 0, maxStepLength) * id.z;
        //float3 curRayPt = curRayOrigin + distOnRay * curRayDir;
        
        /*for (int i = 0; i < particleCount; i++)
        {
            if (distance(particleBuffer[i].position, curRayPt) < testRad)
            {
            
            }
        }*/
        
        result[id.xy] = float4(id.x & id.y, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 1.0);
    }
    else
    {
        result[id.xy] = float4(0, 0, 0, 0);
    }
}
